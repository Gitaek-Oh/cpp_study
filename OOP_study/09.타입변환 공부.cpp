#include <iostream>
using namespace std;

class Knight
{
public:
	int _hp = 10;
};

class Dog
{
public:
	
	Dog()
	{

	}

	// 타입 변환 생성자
	Dog(const Knight& knight)
	{
		_age = knight._hp;
	}

	//타입 변환 연사나자
	operator Knight()
	{
		return (Knight)(*this);
	}
public:
	int _age = 1;
	int _cuteness = 2;
};

class BullDog : public Dog
{
public:
	bool _french; //프렌치 불독
};


int main()
{
	
	// ----------------------- 타입 변환 유형 (비트열 재구성 여부) ----------------------- 
	// [1] 값 타입 변환
	// 특징) 의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성
	{
		int a = 123456789; // 2의 보수 
		// (075bcd15) -> 16진수로 저장됨 (메모리)
		
		float b = (float)a; // 부동소수점(지수 + 유효 숫자) 
		// (4ceb79a3) -> 원본 비트와 다른 비트열로 재구성됨 -> 값 타입 변환이라고 한다.
		cout << b << endl;
	}

	// [2] 참조 타입 변환
	// 특징) 비트열을 재구성하지 않고 '관점'만 바꾸는 것
	// 거의 쓸 일은 없지만, 포인터 타입 변환도 '참조 타입 변환' 동일한 룰을 따르니까 일석이조로 공부하자...
	{
		int a = 123456789; // 2의 보수 
		// (075bcd15) -> 16진수로 저장됨 (메모리)

		float b = (float&)a; // 부동소수점(지수 + 유효 숫자) , & 참조를 붙여준다
		// (075bcd15) -> 데이터를 유지함
		cout << b << endl; // 테이터를 바라보는 관점이 달라져서 출력 값이 달라진다
	}

	// ----------------------- 안전도 분류 ----------------------- 
	// [1] 안전한 변환
	// 특징) 의미가 항상 100% 완전히 일치하는 경우
	// 같은 타입이면서 크기만 더 큰 바구니로 이동
	// 작은 바구니 -> 큰 바구니로 이동 OK (업캐스팅)
	// ex) chat -> short, int -> __int64
	{
		int a = 123456789;
		__int64 b = a;
		cout << b << endl; 
	}

	// [2] 불안전한 변환
	// 특징) 의미가 항상 100% 일치한다고 보장하지 못하는 경우
	// 타입이 다르거나 같은 타입이지만 큰 바구니 -> 작은 바구니로 이동하는 경우(다운캐스팅)
	{
		int a = 123456789;
		float b = a;
		short c = a;
		cout << b << endl;
		cout << c << endl; // 데이터가 손실, 앞에 16비트가 삭제되서 값이 달라짐
	}
	
	// ----------------------- 프로그래머 의도에 따라 분류 -----------------------
	// [1] 암시적 변환
	// 특징) 이미 알려진 타입 변환 규칙에 따라서 컴파일러 '자동'으로 타입 변환
	{
		int a = 123456789;
		float b = a; // 암시적으로
	}
	
	// [2] 명시적 변환
	{
		int a = 123456789;
		int* b = (int*)a; // 명시적으로
	}

	// ----------------------- 아무런 연관 관계가 없는 클래스 사이의 변환 -----------------------
	// [1] 연관없는 클래스 사이의 '값 타입' 변환
	// 특징) 일반적으로 안 됨(예외: 타입 변환 생성자, 타입 변환 연산자)
	{
		Knight knight; // 스택 메모리에 올림
		Dog dog = (Dog)knight; // 타입 변환 생성자 참고

		Knight knight2 = dog; // 타입 변환 연산자 참고
	}

	// [2] 연관없는 클래스 사이의 참조 타입 변환
	{
		Knight knight;
		// 어셈블리 관점에서는 포인터 = 참조
		
		// 위에 버전인 값 타입 장치는 객체를 대상(데이터)으로 다루고 있기 때문에 문제가 생길수 있지만
		// [ 주소 ] -> [ Dog ]라는 형태만 만들어주기 때문에, 문법자체에는 일단 문제가 없기 때문에 통과시켜준다.....?
		Dog& dog = (Dog&)knight;
		dog._cuteness = 12;
	}

	// ----------------------- 상속 관계가 없는 클래스 사이의 변환 -----------------------
	// 특징) 자식->부모 OK	/	부모->자식 NO
	// [1] 상속 관계 클래스의 값 타입 변환
	{
		//Dog dog;
		//BullDog bulldog = dog; //age, cuteness을 가지고 있는 dog에서 _french만 가저온다 -> 오류 발생

		BullDog bulldog;
		Dog dog = bulldog; //age, cuteness, _french을 가지고 있는 bulldog에서 age, cuteness만 가저온다
	}

	// [2] 상속 관계 클래스의 참조 타입 변환
	// 특징) 자식->부모 OK	/	부모->자식 (암시적NO, 명시적OK)
	{
		//Dog dog;
		//BullDog& bulldog = (BullDog & )dog; -> 오류발생

		BullDog bulldog;
		Dog& dog = bulldog;
		// [ age, cuteness, _french ] = [ age, cuteness ] 
	}
	/*
		결론)
		[값 타입 변환] : 진짜 비트열도 바꾸고 논리적으로 말이 되게 바꾸는 변환
		- 논리적으로 말이 된다? (ex. BullDog -> Dog) Ok
		- 논리적으로 말이 안 된다 (ex. Dog -> BullDog, Dog -> Knight) No
		
		[참조 타입 변환] : 비트열은 냅두고 우리의 '관점'만 바꾸는 변환
		- 땡깡 부리면(명시적 요구) 해주긴 하는 데, 말 안해도 그냥 해주는 것(암시적)으로 해주는지는 안전성 여부와 연관있음
		-- 안전하다? (ex. BullDog -> Dog&) 그냥 암시적으로 OK
		-- 위험하다? (ex. Dog -> BullDog&)
		--- 메모리 침범 위험이 있는 경우는 그냥 암시적으로 해주진 않음 (위험하니까)
		--- 명시적으로 정말 정말 하겠다고 최종 서명을 하면 OK
	*/
	return 0;
}
